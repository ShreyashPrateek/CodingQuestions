class Solution {
    public List<List<String>> solveNQueens(int n) 
    {
        // List to store the final solutions
        List<List<String>> res = new ArrayList<>();

        // Boolean arrays to keep track of columns and diagonals where queens are placed
        boolean[] col = new boolean[n];
        boolean[] diag1 = new boolean[2 * n]; // row - col + n
        boolean[] diag2 = new boolean[2 * n]; // row + col

        // Initialize the chessboard with '.' indicating empty spaces
        char[][] board = new char[n][n];
        for (char[] row : board) // Iterate through each row of the board
            Arrays.fill(row, '.'); // Fill the board with '.' to represent empty spaces

        // Start the backtracking process from the first row
        backtrack(0, n, board, col, diag1, diag2, res); // Backtracking function to place queens row by row
        return res;
    }

    // Backtracking function to place queens row by row
    private void backtrack(int row, int n, char[][] board,
        boolean[] col, boolean[] diag1,
        boolean[] diag2, List<List<String>> res)  // Backtracking function to place queens row by row
        {
        // If we have placed queens in all rows, we found a valid solution
        if (row == n) 
        {
            // Convert the current board configuration to a list of strings and add it to the result
            List<String> solution = new ArrayList<>();
            for (char[] r : board) // Convert each row of the board to a string and add to the solution list
                solution.add(new String(r)); // Convert char array to String and add to solution
            res.add(solution); // Add the current solution to the result list
            return; // Backtrack to explore other configurations
        }

        // Try placing a queen in each column of the current row
        for (int c = 0; c < n; c++) 
        {
            // Check if placing a queen at (row, c) is safe by checking the column and diagonals
            if (col[c] || diag1[row - c + n] || diag2[row + c])
                continue; // If it's not safe to place a queen, skip to the next column

            // Place the queen on the board and mark the column and diagonals as occupied
            board[row][c] = 'Q';
            col[c] = diag1[row - c + n] = diag2[row + c] = true; // Mark the column and diagonals as occupied

            // Move to the next row to place the next queen
            backtrack(row + 1, n, board, col, diag1, diag2, res);

            // Backtrack: remove the queen from the board and unmark the column and diagonals
            board[row][c] = '.';
            col[c] = diag1[row - c + n] = diag2[row + c] = false; // Unmark the column and diagonals to explore other configurations
        }
    }
}